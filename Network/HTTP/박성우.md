### HTTP 1.0

한 번의 요청이 있을 때마다 한 번의 커넥션을 만들어야한다.

따라서 여러 개의 리소스를 요청하기 위해서는 여러 번의 커넥션을 생성하고 끊어야한다.

이런 과정이 latency를 만들어낸다.

### HTTP 1.1

keep alive를 기본으로 사용하여 TCP 커넥션을 생성하는 비용을 감소 시켰다.

HTTP 요청에 대한 응답이 순차적으로 이루어져야하기 때문에 성능상의 문제가 발생한다.

나중에 도착한 요청이 먼저 도착한 요청의 작업보다 먼저 끝나도, 먼저 응답으로 보내질 수 없다.

이것이 Head of Line Blocking 문제이다.

### HTTP 2

스트림 : 전송되는 데이터에 특별한 식별자를 붙여준 것

멀티 플렉싱 : 하나의 TCP 커넥션을 통해서 여러 개의 데이터를 병렬적으로 처리할 수 있다.

하나의 TCP 커넥션 위에서 데이터들을 연속적으로 전송하는데, 그에 대한 식별자가 붙어있는 형태로 전송된다.

### TCP Head of Line

TCP는 데이터의 순서를 보장해준다.

따라서 먼저 전송되어야하는 앞의 데이터에 병목이 생기면, 뒤의 데이터도 병목이 생긴다.

### QUIC

TCP를 사용해서 발생하는 문제를 해결하기 위해서 UDP를 사용한다!

어플리케이션 계층에 신뢰성을 구현했다.

즉, UDP를 기반으로 신뢰성을 가지는 로직을 애플리케이션 계층에 구현했다.

![Untitled2](https://github.com/SoftwareMaestro-Backend-Study/cs-study/assets/79205414/7f44c22d-c9d4-45f7-92c6-8ff428975712)

위의 그림인 HTTP 2는 하나의 TCP chain에서 데이터들이 엮인 상태로 전송이 된다.

그에 반해 아래 그림인 QUIC은 데이터 스트림이 각자 다른 Chain을 갖는다.

따라서 하나의 데이터 스트림에서 병목현상이 생기더라도 전체 Chain이 멈추는 것이 아니라 문제가 생긴 스트림만 멈춘다. 이를 통해 Head of Line 문제를 해결하고, latency를 줄였다.

---

### HTTPS

### HTTP의 문제점

암호화 되어있지 않다. 즉, 누군가가 서버-클라이언트 간의 http 메시지를 볼 수 있다.

### 대칭키 암호화

암복호화에 서로 같은 키를 사용한다.

### 공개키 암호화

암복호화에 서로 다른키를 사용한다. 비밀키와 공개키가 존재한다.

공개키는 모두에게 공유될 수 있지만, 비밀키는 본인만이 알고 있어야한다.

HTTPS 암호화에는 대칭키 방식, 공개키 방식이 모두 사용된다.

### HTTPS 통신 과정

### 1. 서버는 CA에게 서버의 공개키를 제출

- CA는 자신의 CA 비밀키를 이용해 인증서를 암호화한다. (공개키 방식)
- CA는 암호화된 인증서를 서버에게 준다.
- 인증서 안에는 서버의 **공개키** + **서비스의 정보** (공개키의 내용 + 공개키 암호화 방법)

### 2. client hello - 클라이언트가 서버에 접속

### 3. server hello

- 서버가 브라우저에게 인증서를 제공한다.

### 4. 브라우저에서 인증서 확인

- 브라우저는 내부에 CA의 리스트와 각 CA의 공개키를 가지고 있다.
- 브라우저는 CA의 공개키를 이용해 인증서를 복호화하여 서버의 **공개키**를 얻는다.

### 5. pre master secrete key 생성

- 클라이언트의 대칭키를 서버의 공개키로 암호화한다.

### **6. 서버에게 pre master secrete key 키 전달하기**

- 클라이언트와 서버는 같은 키를 공유하게 된다.  (대칭키 암호화 방식)

### **7. 클라이언트와 서버는 핸드 쉐이크 종료를 서로에게 알린다.**

### **8. 데이터를 주고 받을 때 공유하고 있는 대칭키를 이용해서 암호화한다.**




[참고]

[[10분 테코톡] 🎃손너잘의 HTTP1.1, HTTP2, 그리고 QUIC](https://www.youtube.com/watch?v=ZgSC5K1sUYM)

[[10분 테코톡] 🙆‍♂️아이크의 HTTP 2.0](https://www.youtube.com/watch?v=uhlvXrDpM-Y)

면접을 위한 CS 전공지식 

