# [OS] Race Condition, Critical Section

## 1. Critical Section

임계 구역(Critical Section)은 여러 프로세스(혹은 스레드)가 데이터를 공유할 때 **각 프로세스에서 공유 자원에 접근하는 코드 부분**이다.

### 1.1. OS에서 Critical Section을 다루는 방법

1. 선점형 커널(Preemptive Kernel): 커널 모드에서 실행되더라도 선점될 수 있다.

   → 경쟁 상태 발생 가능

2. 비선점형 커널(Nonpreemptive Kernel): 커널 모드에서 실행되는 process는 선점되지 않는다.

   → 경쟁 상태 발생 X


## 2. Race Condition

경쟁 상태(Race Condition)란 동시에 여러 개의 프로세스가 동일한 자원에 접근해 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상태다.

경쟁 상태를 막기 위해 한 순간에 하나의 프로세스만이 한 자원에 접근하도록 보장해야 하고, 이를 위해 우리는 프로세스들이 동기화 되도록 해야한다.

### 2.1. Race Condition 발생하는 경우

1. 커널 작업을 수행하는 중에 인터럽트 발생
    - 커널모드에서 데이터를 로드해 작업을 수행하다가 인터럽트가 발생해 같은 데이터를 조작하는 경우
    - 해결법: 커널모드에서 작업을 수행하는 동안 인터럽트를 disable시켜 CPU 제어권을 가져가지 못하도록 한다.
2. 프로세스가 시스템 콜(System Call)을 해 커널 모드로 진입하여 작업을 수행하는 도중 컨텍스트 스위칭(Context Switching)이 발생
    - 프로세스 1이 커널모드에서 데이터를 조작하는 도중, 시간이 초과돼 CPU 제어권이 프로세스 2로 넘어가 같은 데이터를 조작하는 경우(프로세스 1이 작업에 반영되지 않음)
    - 해결법: 프로세스가 커널모드에서 작업을 하는 경우 시간이 초과되어도 CPU 제어권이 다른 프로세스에 넘어가지 않도록 함
3. 멀티 프로세서 환경에서 공유 메모리 내 커널 데이터에 접근
    - 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근해 조작하는 경우
    - 해결법: 커널 내부에 있는 각 공유 데이터에 접근할 대마다, 그 데이터에 대한 Lock/Unlock을 함

### 2.2. Race Condition 문제점

스레드 1이 공유 자원에 접근해 먼저 조회한 뒤 공유 자원을 업데이트하기 전에 컨텍스트 스위칭이 발생해 프로그램 실행 흐름이 스레드 2로 교체되고, 스레드 2에서 공유 자원을 업데이트한 후 컨텍스트 스위칭이 발생해 실행 흐름이 다시 스레드 1로 교체되어 스레드 1이 수행 중이던 업데이트 작업을 수행할 때 무결성 혹은 정합성이 깨질 수 있다.

1. 무결성 위반

   예시) 통장 잔고 5000원인 공유 자원에 5000원 출금 작업을 수행하려는 스레드 1, 2가 접근할 때 위와 같은 경우 출금 후 잔고가 -5000원이다.

2. 정합성 위반

   예시) 통장 잔고 5000원인 공유 자원에 5000원 입금 작업을 수행하려는 스레드 1, 2가 접근할 때 위와 같은 경우 입금 후 잔고가 10000원이 아닌 15000원이다.


### 2.3. Race Condition 해결 방안

경쟁 상태 문제를 해결하기 위해서는 다음 세 가지 요구조건을 충족해야 한다.

1. 상호 배제(Mutual Exclusion)

   어떤 프로세스가 자기 임계 구역에서 실행된다면, 다른 프로세스들은 그 임계 구역에서 실행될 수 없다.

2. 진행(Progress)

   어떤 임계 구역에서 실행되는 프로세스가 없고 그 임계 구역으로 진입하려는 프로세스가 있다면 임계 구역에 진입할 수 있어야 한다. 즉, 임계 구역에 있는 프로세스 외에는 다른 프로세스가 임계 구역에 진입하는 것을 방해하면 안된다.

3. 한정된 대기(Bounded Waiting)

   프로세스가 임계 구역에 진입하려는 요청을 한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 해당 임계 구역에 진입하도록 허용되는 횟수에 한계가 있어야 한다.

   → 기아 상태(Starvation) 방지


**Mutex Lock**

Mutex는 Mutual Exclusion의 줄임말로, 뮤텍스 락(Mutex Lock)은 상호 배제를 위해 임계 구역에 들어가기 전에 반드시 락을 획득(`acquire()`)해야 하고 임계 구역을 빠져나올 때 락을 반환(`release()`)한다.

뮤텍스 락은 available이라는 불린 변수가 락의 가용 여부를 표시한다. available 변수가 true이면 `acquire()` 호출이 성공하고 락이 사용불가 상태(available = false)가 된다. 사용불가 상태의 락을 획득하려고 시도하는 프로세스는 락이 반환될 때까지 봉쇄된다.

뮤텍스 락의 단점은 바쁜 대기(Busy Waiting)를 해야 한다는 것이다. 프로세스가 임계 구역에 있는 동안 임계 구역에 들어가기 원하는 다른 프로세스들은 `acquire()` 함수를 반복해서 호출해야 한다(스핀락, Spin Lock).

**Semaphore**

세마포어(Semaphore)는 정수 변수(S)를 가지고 있어 초기화를 제외하고 `wait()`(P)와 `signal()`(V)로만 공유 자원에 접근한다.

프로세스가 wait()를 호출해 공유 자원에 접근했을 때 세마포어 정수가 음수가 아니면 세마포어 정수가 1 감소하고, 음수면 세마포어 대기열에서 기대린다.

프로세스가 공유 자원을 모두 사용하고 임계 구역을 벗어날 때 signal()을 호출해 세마포어 정수를 1 증가시키고 세마포어 대기열에서 기다리고 있는 맨 앞의 프로세스 하나를 깨워 공유 자원 접근을 허용한다.

세마포어 정수의 크기에 따라 아래 두 가지로 구분된다.

1. 계수 세마포어(Counting Semaphore): 1보다 큰 세마포어 정수를 가진다.
2. 이진 세마포어(Binary Semaphore): 세마포어 정수를 0과 1로만 가진다.
    - 뮤텍스와 비슷하게 동작
    - 뮤텍스는 잠금 매커니즘이고 세마포어는 신호 기반의 상호 배제 방법으로, 차이가 있다.

**Monitor**

세마포어를 사용할 때 모든 프로세스는 임계 구역에 진입하기 전에 wait()를 실행해야 하고, 임계 구역을 나올 때 signal()을 호출해야 한다. 만약 이 순서가 지켜지지 않으면 두 프로세스가 동시에 임계구역 안에 있을 수 있다. 이런 문제를 해결하기 위해 모니터(Monitor)라는 동기화 도구가 등장했다.

세마포어는 임계 구역에 명시적으로 상호 배제 로직을 구현해야 하지만, 모니터는 이 상호 배제 로직을 추상화하고 공유 자원 접근에 대한 인터페이스를 제공한다. 또한 공유 자원도 외부로부터 캡슐화하여 숨긴다.

모니터는 주로 고급 프로그래밍 언어에서 제공하는 방식이다.

자바의 `synchronized` 키워드도 모니터를 사용해 구현되었다.

공유 자원에 접근하고자 하는 프로세스 또는 스레드는 모니터 안으로 들어가야 한다. 모니터는 모니터큐에 작업을 순차적으로 쌓아두고, 한 번에 한 프로세스 또는 스레드만 임계 구역에 접근할 수 있도록 한다(한 번에 하나의 프로세스만 모니터에서 활동할 수 있도록 보장).

개념적으로는 이진 세마포어의 기능을 제공하는 것이다.

## References

[Operating System Concepts 에센셜](https://product.kyobobook.co.kr/detail/S000001732281)

[경쟁상태, 임계영역의 개념과 동기화를 위한 여러 상호배제 기법 (mutex, semaphore, monitor)](https://hudi.blog/race-condition-critical-section-mutual-exclusion/)

[경쟁 상태(Race Condition)](https://gyoogle.dev/blog/computer-science/operating-system/Race%20Condition.html)