## 가상 메모리란(Virtual Memory)

운영체제(OS)는 메모리가 실제 메모리보다 많아 보이게 하는 기술인 가상 메모리를 제공한다. 가상 메모리는 컴퓨터 시스템의 메모리 관리 기법 중 하나이다. 이는 프로그램에게 물리 메모리보다 더 큰 메모리 공간을 제공함으로써, 프로그램이 사용하는 메모리를 물리적으로 실제 메모리 크기보다 크게 만들 수 있다.

가상 메모리는 시스템이 **프로그램을 실행시키는데 최소한 얼마만큼의 메모리가 필요한가에 대한 접근 방식으로, 실행에 필요한 일부분만 메모리에 로드하고 나머지는 디스크에 두고서 필요할 때마다 교체하면서 쓰는 방식**으로 구현된다.

![image](https://github.com/SoftwareMaestro-Backend-Study/cs-study/assets/83508073/35c652f6-3897-4f4e-8f7e-be91670cc077)

### 가상 메모리 장점

- 프로그램이 더 큰 주소 공간을 사용할 수 있게 한다.
    - 메모리 크기의 제약으로부터 자유로워졌고 사용자 프로그램이 실행에 필요한 최소 크기의 메모리만 올라가져 있기 때문에 더 많은 프로그램을 동시 수행 가능해졌다.
- 메모리 관리 및 보호를 쉽게 한다.
    - 추가 권한 비트를 사용하여 각 프로세스에 메모리에 대한 제한된 액세스 권한을 부여하여 메모리를 보호한다. OS는 권한 비트를 확인하여 한 프로세스가 다른 프로세스의 메모리 공간을 손상시키지 않도록 할 수 있다.
- 더 효율적인 메모리 사용을 가능하게 하여 시스템 성능을 향상시킨다.

## 요구 페이징 (Demand Paging)

필요한 부분만 요청이 있을 때 물리적 메모리에 **페이지**단위로 적재하는 방법을 **요구 페이징**이라고 한다.

이 방식은 프로그램의 실행 초기에 모든 페이지를 메모리에 적재하는 대신 특정 페이지에 대해 CPU 요청이 들어오면 해당 page를 메모리에 적재하여 메모리 사용을 최적화한다.

**Valid-Invalid bit scheme**

- bit is set to “**valid**” : page가 메모리에 있음
- bit is set to “**invalid**” : Invalid한 page이거나. valid한 page이지만, 현재 secondary storage에 있음

![image](https://github.com/SoftwareMaestro-Backend-Study/cs-study/assets/83508073/643a6c7f-164b-47ca-b16c-dd7cbec9537e)

***프로세스가 메모리에 올라와 있지 않은 페이지에 접근하려고 할 때 ⇒ page fault***

- ***page fault :*** invalid한 page에 접근할 시 발생 → trap 발생시켜서 처리한다.

## 페이지 부재 (Page fault)

페이지 부재(page fault)란 프로그램이 참조하려는 페이지가 메모리에 없어서 발생하는 현상이다. 이는 프로그램의 실행을 중단시키며, 시스템은 부재된 페이지를 디스크에서 찾아 메모리에 로드해야 한다.

### 페이지 부재 처리 과정

![image](https://github.com/SoftwareMaestro-Backend-Study/cs-study/assets/83508073/105dd448-b480-4313-8117-285d7ea67f8d)

(1) CPU가 가상 주소를 MMU에게 요청하면,

(2) **MMU**는 먼저 **TLB**(Translation Lookside Buffer)로 가서 그 가상주소에 대한 물리주소가 캐싱돼 있는지 확인한다.

(3) **TLB**에 캐싱된 물리주소가

- 있으면 MMU가 해당 페이지의 물리 주소로 데이터를 갖고 와서 CPU에게 보내고
- 없으면 MMU가 CR3 레지스터를 가지고 물리 메모리에 해당 프로세스의 페이지 테이블에 접근한다.

(4) MMU가 페이지 테이블에서 물리주소가 있는지 valid bit를 확인한다.

(5) valid bit의 값이

- 1이면 MMU가 해당 페이지의 물리 주소로 데이터를 갖고 와서 CPU에게 보내고
- 0이면 MMU가 페이지 폴트 인터럽트를 운영체제에 발생시킨다.

(6) 운영체제는 해당 페이지를 저장공간에서 가져온다.

(7) 운영체제는 저장공간에서 가져온 데이터를 메모리에 올려주고, 페이지 테이블을 업데이트 해준다. valid bit -> 1, 물리주소 업뎃

(8) 운영체제는 CPU에게 프로세스를 다시 실행하라고 한다.

(9) CPU는 다시 MMU에 가상 주소를 요청한다.

**MMU(Memory Management Unit)**: 가상 주소를 물리 메모리 주소로 변환해주는 하드웨어 장치


## 페이지 교체 알고리즘

multiprogramming의 정도가 높아지면 **over-allocation memory**가 발생 가능하다.  즉, **프로세스가 실제로 필요한 양보다 더욱 많은 양의 메모리가 할당되는 것**이다.

따라서 이때는 **적당한 프로세스를 골라서 page을 재할당시켜야 한다.** (**page replacement**)

어떤 페이지를 교체할 것이냐를 결정하는 알고리즘은 아래와 같다.

- `FIFO(First-In, First-Out)`: 메모리에 적재된 것 중 가장 먼저 들어온(오래된) 페이지를 교체
    - 구현이 쉽지만, 잘못된 페이지 교체가 발생할 수 있고, 프로세스 실행 속도를 느리게 한다.
- `LRU(Least Recently Used Algorithm)`: 사용 가능성이 낮은 페이지를 우선적으로 교체
    - 시간 지역성을 이용해 가장 오래 전에 참조가 이루어진 페이지를 교체
- `LFU(Least Frequently Used Algorithm)`: 과거에 참조 횟수가 가장 적은 페이지를 교체
    - 메모리에 적재될 때부터 페이지의 횟수를 카운트하는 Incache-LFU 방식
    - 메모리 적재여부와 상관 없이 참조 횟수를 카운트하는 Perfect-LFU 방식
    

## Trashing

**스레싱(Thrashing)이란 페이지 부재율(Page fault)이 증가하여 CPU 이용율이 급격하게 떨어지는 현상**을 얘기한다. 

스레싱이 발생하는 이유는 프로세스를 처리하는 시간보다 메모리에 적재되지 못한 페이지로 인하여 페이지 교체에 드는 시간이 증가하게되고 그로 인해 CPU이용률이 떨어지게 된다.

- 활발하게 사용되는 페이지 집합을 지원해 줄 만큼 프레임이 충분히 할당 받지 못한 프로세스는 페이지 폴트(Page fault)가 발생
- 이 때, 페이지 교체가 필요하지만 이미 활발히 사용되는 페이지들만으로 이루어져 있으므로 어떤 페이지가 교체되던 바로 다시 페이지 교체가 필요
- 결과적으로 바로바로 반복해서 페이지 폴트가 발생하며, 교체된 페이지는 또 다시 얼마 지나지 않아 읽어올 필요가 생기게 됨. 이렇게 과도한 페이징 작업을 쓰레싱이라 함

![image](https://github.com/SoftwareMaestro-Backend-Study/cs-study/assets/83508073/1a4582a2-a706-40d5-8a52-22ab2298356c)

운영체제는 CPU 이용율이 낮으면 메모리에 동시에 올라가 있는 프로세스의 수인 MPD(다중 프로그래밍의 정도, Multi-Programming Degree)를 높이게 되는데 동시에 실행하는 프로세스가 많아질 수록 각 프로세스에 할당된 메모리 페이지 프레임들은 더욱 작아지게 된다. 너무 적은 페이지 프레임을 할당받은 프로세스들은 페이지 부재가 증가하게되어 Swapping이 증가하게 되고 결국 CPU의 이용율이 더욱 떨어지는 악순환이 생기게 된다.
