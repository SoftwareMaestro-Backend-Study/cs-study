# [Operating System] Virtual Memory

# Virtual Memory

## 1. Virtual Memory

가상 메모리(Virtual Memory)는 메모리 관리 기법 중 하나로 실제 이용 가능한 메모리 자원보다 큰 메모리처럼 보이게 하는 기술이다.

### 1.1. Virtual Memory 등장 배경

실행 중인 프로세스 정보가 모두 물리적 메모리에 저장된다고 할 때, 실행 중인 프로세스가 많을수록 각 프로세스에게 할당되는 물리적 메모리의 크기가 작아진다.

다른 프로세스를 올려야하는데 물리적 메모리의 공간이 부족하면 기존 프로세스를 스왑 영역으로 보내고(Swap Out), 해당 프로세스를 물리적 메모리에 올린다.

이렇게 되면 스왑 영역과의 I/O가 빈번하게 발생하고, 물리적 메모리의 크기보다 큰 프로세스라면 아예 실행조차 불가능하게 된다.

이러한 불편함을 해소하고자 가상 메모리의 개념이 등장했다.

### 1.2. Virtual Memory 구성

가상 메모리는 실제 메모리 상에 있는 **물리 메모리(Physical Memory)**와 실제 메모리 상에는 없는 **논리 메모리(Logical Memory)**로 분리한다.

가상 메모리를 사용하면 프로세스 전체의 내용을 메모리에 올릴 필요 없이 필요한 부분만 메모리에 올려 실행이 가능하다.

가상 주소는 **메모리관리장치(MMU)**에 의해 실제 주소로 변환되며, 이 덕분에 사용자는 실제 주소를 의식할 필요없이 프로그램을 구축할 수 있다.

가상 메모리는 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어 있는 **페이지 테이블**로 관리되며 속도 향상을 위해 **TLB**를 사용한다.

> **TLB**
> 
> : 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시
> 
> (페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시킬 수 있는 캐시 계층이다.)

### 1.3. Virtual Memory 장점

1. 사용자 프로그램이 물리 메모리의 제약에서 벗어남
2. 각 프로그램이 더 작은 메모리를 차지하기 때문에 더 많은 프로그램을 동시수행 가능(한 것처럼 보임)
3. 프로그램을 메모리에 올리고 스왑(Swap)하는데 필요한 IO 횟수가 줄어듦

## 2. Demand Paging

요구 페이징 기법(Demand Paging)은 필요한 페이지만 물리 메모리에 적재하는 방법이다.

주소 공간이 하나의 단위가 아니라 여러 개의 페이지로 나누어져 있어, 그 중에서 지금 당장 필요한 페이지들만 메모리에 적재한다.

<img width="320" alt="스크린샷 2023-07-01 오후 4 03 00" src="https://github.com/SoftwareMaestro-Backend-Study/cs-study/assets/62989828/2919cf21-f2d9-4681-b7d0-114973b2db10">

필요한 페이지가 물리 메모리에 올라와 있는지 판단하기 위해 유/무효 비트를 사용한다.

- Valid: 해당 페이지가 메모리에 있음
- Invalid: 해당 페이지가 메모리에 없음 = 페이지 폴트(Page Fault)
    - 해당 페이지가 가상 공간에 없음 → 해당 프로세스 중단
    - 보조저장장치에 존재 → 보조저장장치에서 가져옴

### 2.1. Page Fault

페이지 폴트(Page Fault)는 프로세스의 주소 공간에는 존재하지만 실제 메모리인 RAM에는 없는 데이터에 접근했을 경우 발생한다.

페이지 폴트와 이로 인한 스와핑 동작 과정

1. CPU는 물리 메모리를 확인해 해당 페이지가 없으면 트랩을 발생시켜 운영체제 알린다.
2. 운영체제는 CPU의 동작을 잠시 멈춘다.
3. 운영체제는 페이지 테이블을 확인해 가상 메모리에 페이지가 존재하는지 확인한다.

   3-1. 페이지 테이블에 없으면 프로세스를 중단하고 현재 물리 메로리에 비어 있는 프레임을 찾는다.

   3-2. 물리 메모리에도 없으면 스와핑이 발동된다.

4. 비어 있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화한다.
5. 중단되었던 CPU를 다시 시작한다.

> **페이지(Page)**
> 
> : 가상 메모리를 사용하는 최소 크기 단위

> **프레임(Frame)**
> 
> : 실제 메모리를 사용하는 최소 크기 단위
> 

### 2.2. Swapping

스와핑(Swapping)은 페이지 폴트가 발생했을 때 메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 마치 메모리처럼 불러와 쓰는 것이다.

스와핑을 통해 마치 페이지 폴트가 일어나지 않은 것처럼 만든다.

### 2.3. 페이지 교체 알고리즘

스와핑은 페이지 교체 알고리즘을 기반으로 일어난다.

1. 오프라인 알고리즘(Offline Algorithm)
    - 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘(가장 좋은 방법)
    - 먼 미래에 사용되는 프로세스를 알 수 없기 때문에 사용할 수 없지만 다른 알고리즘과의 성능 비교에 대한 기준을 제공
2. FIFO(First In First Out)
    - 가장 먼저 들어온 페이지를 교체
3. LRU(Least Recently Used)
    - 참조가 가장 오래된 페이지를 교체
    - 언제 참조됐는지를 파악하기 위해 각 페이지마다 계수기, 스택을 두어야하는 문제점이 있음
4. NUR(Not Used Recently)
    - 0(참조되지 않음)과 1(최근 참조)을 가진 비트를 두고, 시계 방향으로 돌면서 0을 찾고 0을 찾은 순간 해당 프로세스를 교체하고 해당 부분을 1로 바꾸는 알고리즘
    - Clock Algorithm이라고도 함
5. LFU(Least Frequently Used)
    - 가장 참조 횟수가 적은 페이지 교체

## References

[[10분 테코톡] 배럴의 가상 메모리](https://www.youtube.com/watch?v=5pEDL6c--_k)

[면접을 위한 CS 전공지식 노트](https://www.googleadservices.com/pagead/aclk?sa=L&ai=DChcSEwia9eSundf_AhWMxUwCHZzcAiwYABAAGgJ0bQ&ae=2&ohost=www.google.com&cid=CAESbOD2RfjukXbcAqRpoyk9ejMa1U5JbDMF8IwE8d1BVdtw-g9yULTyQXwVzdkgqaATwg3m96Bu0xF6apWbbuvEWm4vGlsKJIQA4hJbWtBTBB_SwDlVenO7G6nDfd086vuI5_djt0aYAgXSbzz4Dw&sig=AOD64_2NzWNlDpYct6p0Y2Pp-eMeDi8nPA&q&adurl&ved=2ahUKEwjS_92undf_AhURklYBHe27CKkQ0Qx6BAgGEAE&nis=2&dct=1)