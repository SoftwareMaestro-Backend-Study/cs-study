## 프로세스 & 쓰레드

- 프로세스
    - ✅ **프로세스: 운영체제로부터 자원을 할당받는 작업의 단위.**
    - **컴퓨터에서 실행중인 프로그램**
    - **각자 고유한 공간과 자원을 할당받는다.**
    - 각각의 code, data, stack, heap 영역을 보유
    - 각각의 영역을 갖기에 동기화 작업이 필요하지 않음
    - 각각의 영역을 갖기에 컨텍스트 스위칭 비용이 크다.

    ![image](https://github.com/SoftwareMaestro-Backend-Study/cs-study/assets/83508073/e4b64d9c-4eda-4c5f-a471-f6994d8626e6)
    
- 스레드
    - ✅ **스레드: 프로그램(프로세스) 실행의 단위.**
    - **한 프로세스의 내의 실행 단위**
    - **stack만 고유한 영역을 갖고 나머지 영역은 프로세스 자원을 공유**
    - stack 이외의 영역을 공유하므로 동기화 작업이 필요
    - stack 이외의 영역을 공유하므로 컨텍스트 스위칭 비용이 적음
    
    ![image](https://github.com/SoftwareMaestro-Backend-Study/cs-study/assets/83508073/e9546a02-3fe1-4090-a3fe-9280503db7f4)
    

여러 개의 어플리케이션을 사용한다면, 여러 개의 프로세스(multi-process)가 동작 중이다.

하나의 어플리케이션(프로세스)를 실행할 때도 여러 개의 스레드(multi-thread)를 사용할 수 있다.

⭕ **멀티 프로세스 -> 멀티 스레드**

❌ **멀티 스레드 -> 멀티 프로세스**

## Multi-Processing VS Multi-Threading

- **Multi-Processing**
    - **하나의 프로그램을 여러 개의 프로세스로 구성하여 프로세스가 병렬적으로 작업을 수행하는 것**
    - 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 끼지지 않는다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간을 차지하는 단점이 있다.
- **Multi-Threading**
    - **하나의 프로세스를 여러 개의 스레드로 구성하여 자원을 공유하면서 작업을 수행하는 것**
    - 멀티 프로세스보다 적은 메모리 공간을 차지하고 Context Switching이 빠른 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제를 가지고 있다.
- 멀티 프로세싱 대신에 멀티 쓰레딩을 사용하는 이유
    - 프로그램을 여러 개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것이 더욱 효율적이기 때문이다.
    - 컨텍스트 스위칭 시 stack 영역만 초기화하면 되기 때문에 더 빠르다.
    - 프로세스를 생성하여 자원을 할당하는 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
    

## Context Switching

- **여러 프로세스를 처리해야 하는 상황에서 현재 진행중인 Task(프로세스, 스레드)의 상태를 PCB에 저장하고 다음에 진행할 Task의 상태값을 읽어 레지스터에 적재하는 과정**
- 다음에 실행할 Task의 PCB정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행한다.
    - register는 CPU내부의 요청을 처리하는 데 필요한 데이터를 일시적으로 저장하는 작은 기억장치
- **컨텍스트 스위칭을 진행하는 동안 다른 작업을 할 수 없다.** -> 오버헤드의 원인
    - 오버헤드란 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간, 메모리 등을 의미한다.
    - A 라는 작업 처리에 단순히 10초가 걸리는데 안정성 고려하려 처리했더니 15초가 걸린경우 오버헤드는 5초이다.
- **한 프로세스의 상태는 그 프로세스의 프로세스 제어 블록(PCB)에 기록되어 있다.**

### 진행 과정

1. CPU가 다른 프로세스로 전환하면 시스템은 프로세스의 상태를 PCB에 저장한다.
2. 대기열에서 다음 프로세스를 선택하고 PCB를 **복원** 한다.
3. PCB의 **프로그램 카운터(레지스터)** 가 로드되어 선택한 프로세스에서 실행을 계속한다.
![image](https://github.com/SoftwareMaestro-Backend-Study/cs-study/assets/83508073/e1c4515a-afd4-4c9a-8b3b-3a6c5df5756b)

