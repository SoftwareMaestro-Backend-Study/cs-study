# **리플렉션 (Reflection)**
![image](https://github.com/SoftwareMaestro-Backend-Study/cs-study/assets/83508073/c1e093a6-4220-48a7-a112-4166d1a54cea)

JVM은 **클래스 정보를 클래스 로더를 통해 읽어와서 해당 정보를 JVM 메모리에 저장하는데,**

힙 영역에 **로드된 Class 타입의 객채**를 통해서, 원하는 **클래스의 인스턴스를 생성**할 수 있도록 지원하고, **인스턴스의 필드와 메소드를 접근 제어자와 상관없이 사용**할 수 있도록 지원하는 API이다.

리플렉션을 사용하면 클래스와 메소드에 어떤 어노테이션이 붙어 있는지 확인할 수 있다. 어노테이션은 그 자체로는 아무 역할도 하지 않는다. 리플렉션 덕분에 우리가 스프링에서 **`@Component`** , **`@Bean`** 과 같은 어노테이션을 프레임워크의 기능을 사용할 수 있다.

원래라면, 컴파일 시점에 객체의 타입이 결정되기 때문에 구체적인 클래스를 모르면 해당 클래스 정보에 접근할 수 없었다. (Object로 타입을 선언하면 구체적인 클래스 정보에 접근 불가능)

하지만 리플렉션 api를 사용하면 구체적인 타입이 정해지지 않더라도 클래스 정보에 접근할 수 있다.

- **`java.lang.Class`**: 클래스와 인터페이스의 메타데이터를 표현
- **`java.lang.reflect.Method`**: 클래스나 인터페이스의 메소드에 대한 정보를 표현하고, 해당 메소드를 호출하는데 사용됨
- **`java.lang.reflect.Field`**: 클래스의 필드에 대한 정보를 표현하고, 해당 필드의 값을 가져오거나 설정하는데 사용됨
- **`java.lang.reflect.Constructor`**: 클래스의 생성자에 대한 정보를 표현하고, 해당 생성자를 사용하여 새 인스턴스를 생성하는데 사용됨

## Reflection API의 작동 원리

1. 클래스 로딩: 모든 자바 클래스는 JVM에 로드될 때 **`java.lang.Class`** 객체의 인스턴스로 표현된다. 
**`Class`** 객체는 해당 클래스의 모든 메타데이터(클래스 이름, 부모 클래스, 구현한 인터페이스, 필드, 메소드, 생성자 등)를 포함하고 있다.
2. 메타데이터 접근: 리플렉션 API는 이 **`Class`** 객체를 통해 클래스의 메타데이터에 접근한다. 
예를 들어, **`Class`** 객체의 **`getMethods()`** 메소드를 호출하면 해당 클래스의 모든 public 메소드에 대한 **`Method`** 객체 배열을 얻을 수 있다. **`Method`** 객체는 메소드의 이름, 리턴 타입, 파라미터 타입 등 메소드에 대한 메타데이터를 포함하고 있다.
3. 동적 조작: 또한 리플렉션 API는 **`Class`** 객체를 통해 클래스의 인스턴스를 생성하거나(**`newInstance()`** 메소드), 메소드를 실행하거나(**`Method.invoke()`** 메소드), 필드의 값을 변경하는(**`Field.set()`** 메소드) 등의 작업을 할 수 있게 해준다. 이 모든 작업은 런타임에 동적으로 수행된다.

덕분에 런타입 시점에 클래스의 구조를 알아내어 작업을 수행할 수 있다.

# **Class 클래스**

우선, 리플렉션을 사용하기 위해서 힙 영역에 로드된 Class 타입의 객체를 가져와야 한다.

### **Class 객체 획득 방법**

- `클래스.class` 로 가져오기
- `인스턴스.getClass()` 로 가져오기
- `Class.forName("클래스명")` 으로 가져오기

위 3가지 방법으로 Class 타입의 객체를 획득하고, 이를 통해서 인스턴스를 생성하거나 접근 제어자와 상관없이 필드와 메소드에 접근할 수 있다.

- **getConstructors(): 생성자 획득 → newInstance(): 생성자로 인스턴스 획득**
- **getFields()** : 필드 정보, 상속받은 클래스, 인터페이스를 포함하여 모든 public 요소를 가져옴
- **getMethods()** : 메소드 정보, 상속받은 클래스, 인터페이스를 포함하여 모든 public 요소를 가져옴
- **getDeclaredFields()**: 필드 정보, 해당 클래스에 직접 정의된 내용만 가져옴 → private, public, protected
- **getDeclaredMethods()**: 메소드 정보, 해당 클래스에 직접 정의된 내용만 가져옴 → private, public, protected

# **리플렉션의 장단점**

- 장점
    - 동적 로딩: 런타임에서 특정 클래스를 로딩하고 인스턴스를 생성할 수 있는 유연성 제공
    - 동적 코드 분석 및 생성 : 리플렉션을 사용하여 코드 분석 도구나 자동화 도구, 프록시 등을 만들 수 있음
- 단점
    - 캡슐화를 저해함
    - 컴파일 시점에서 타입 체크가 불가능함
    - 런타임 시점에서 인스턴스를 생성하므로 컴파일 시점에서 해당 타입을 체크할 수 없음
    - 런타임 시점에서 인스턴스를 생성하므로 구체적인 동작 흐름을 파악하기 어려움
    - 단순히 필드 및 메소드를 접근할 때보다 리플렉션을 사용하여 접근할 때 대체로 성능이 느림
    - 리플렉션 작업은 일반적인 작업보다 더 많은 시간과 CPU 자원을 소모함
