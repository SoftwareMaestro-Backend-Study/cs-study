# 가시성

CPU cache에 대해서 먼저 이해해보자

CPU는 스레드를 실행할 때 메인 메모리에서 값을 읽어와 실행한다.

메인 메모리와 CPU 사이에는 CPU cache가 존재한다.

CPU는 스레드를 실행할 때 메인 메모리 값을 CPU cache에 담아둔다.

1. 스레드는 값의 변경이 일어나면 CPU cache의 값을 변경하고, 메인 메모리의 값도 변경한다.
2. 이때 다른 스레드는 메인 메모리의 값을 보는 것이 아니라 스레드의 CPU cache를 보고있기 때문에 메인 메모리의 변경된 값을 읽어오지 못한다!

![image](https://github.com/SoftwareMaestro-Backend-Study/cs-study/assets/79205414/e66de902-2e86-4c01-b003-9b82f96506f3)

# 자바에서 가시성을 챙기는 방법 : volatile

volatile을 선언한 변수는 메인 메모리에서만 값을 읽고 쓴다. CPU cache를 사용하지 않는다.

# 동기화

원자성과 가시성을 보장하는 것

# Blocking 방식

스레드가 특정 작업을 수행하는 동안 다른 작업은 진행하지 않고 대기하는 방식

### 1. Synchronized

배타 동기를 선언하는 키워드

연산 결과가 메모리에 써질 때까지 다른 스레드는 대기한다.

![image](https://github.com/SoftwareMaestro-Backend-Study/cs-study/assets/79205414/414b9625-704a-411e-b0b3-d90ca092c572)


순차 접근을 통해 원자성과 가시성을 보장한다.

하지만 대기하는 스레드가 존재하기 때문에, 성능 저하가 발생한다.

# Non Blocking 방식

다른 스레드의 작업여부와 상관업싱 자신의 작업을 수행하는 방식

### CAS(Compare And Set)

자원 값 : 기존의 자원 값

기댓 값 : 가져온 자원 값과 똑같은 값

새로운 값 : 기댓 값에 연산을 통해 만들어진 새로운 값

새로운 값을 자원 값에 덮어쓰기를 해야하는데, 기댓값과 현재 시점의 자원 값이 같다면 새로운 값으로 덮어쓰기를 하고, 다르면 수정하지 않는다.

기댓값과 현재 시점의 자원 값이 다르다는 얘기는, 내가 연산하는 동안 다른 스레드에서 자원 값을 변경했다는 것이다.

CAS를 통해 원자성을 보장한다!!

### Atomic 타입

CAS + Volatile

스레드에서 연산하는 값을 가져올 때 메인 메모리에서 가져온다.

메모리에 값을 저장할 때 comepareAndSet 메소드를 실행한다.

### 동기화를 신경쓸바엔, 그냥 공유 변수 최소화 + 캡슐화 + 문서화를 잘하자
