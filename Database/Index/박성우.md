## 데이터베이스 인덱스

- 데이터베이스 테이블에 대한 검색 성능을 향상시키는 자료구조이다.
- 데이터베이스에서 원하는 값을 빠르게 찾기위해 사용한다!

인덱스를 사용하지 않는다면 Full Table Scan을 진행한다.

1. 인덱스는 항상 최신의 정렬 상태를 유지한다.
2. 인덱스도 하나의 데이터베이스 객체이다.
3. 데이터베이스 크기의 약 10%정도의 저장공간이 필요하다.

### 페이지

데이터가 저장되는 단위

### B-Tree(Balanced-Tree)

1. 트리 높이가 같다.
2. 자식 노드를 2개 이상 가질 수 있다.

![Untitled](https://github.com/SoftwareMaestro-Backend-Study/cs-study/assets/79205414/9ea8559c-1754-4b1b-9bd0-37e86f40b385)


1. 루트 페이지
    - 최상단에 위치한다.
    - 자식 페이지의 정보를 갖는다.
    
2. 브랜치 페이지 
    - 루프 페이지와 리프 페이지 사이에 여러 개가 존재할 수 있다.
    - 자식 페이지의 정보를 갖는다.

1. 리프 페이지
    - 실제 데이터의 페이지(**클러스터링 인덱스**) || 실제 데이터의 주소 페이지(**논클러스터링 인덱스**)

B-Tree 를 사용한 인덱스를 통해 SELECT 성능이 향상된다! 

그러나 **INSERT, UPDATE, DELETE의 성능은 나빠진다.**

### 왜?

- INSERT
    
    페이지가 꽉 차게 되면, 비어있는 페이지를 확보하고, 문제가 있는 페이지의 데이터를 공평하게 나누어 저장
    
    **즉, 페이지 분할이 일어나서 DB가 느려지고 성능에 영향을 준다!**
    
- DELETE
    
    데이터를 실제로 지우지 않고 사용안함 표시를 한다.
    
- UPDATE
    1. 데이터를 사용안함 표시를 한다.
    2. 새로운 데이터를 INSERT 한다.

**정리: 페이지 분할과 사용안함 표시로 인덱스의 조각화가 심해져 성능이 저하된다!**

## 인덱스 종류

### 1. 클러스터링 인덱스

- 실제 데이터와 인덱스가 무리를 이룬다.

클러스터링 인덱스를 만드는 방법 

1. primary key
2. unique + not null  설정

클러스터링 인덱스의 특징

1. 실제 데이터 자체가 정렬되어 있다.
2. 테이블당 1개만 존재 가능하다.
3. 리프 페이지가 데이터 페이지이다.
4. primary key가 unique + not null 보다 높은 우선순위를 갖는다.

### 2. 논클러스터링 인덱스

- 실제 데이터와 인덱스가 다른 무리를 이룬다.

논클러스터링 인덱스를 만드는 방법 

1. unique column 설정
2. unque index 생성
3. index 생성

논클러스터링 인덱스의 특징

1. 테이블 당 여러 개 존재 가능하다.
2. 리프 페이지에 데이터 페이지의 주소가 저장되어있다.

### 논클러스터링 인덱스와 클러스터링 인덱스가 함께 존재한다면?

논클러스터링 인덱스의 **리프 페이지**에 클러스터링 인덱스가 적용된 칼럼의 실제 칼럼의 값을 저장한다.

### 왜 논클러스터링 인덱스의 리프 페이지에 실제 데이터 주소 값이 저장되지 않은걸까?

새로운 데이터가 insert 될 때마다 실제 데이터 주소가 바뀌기 때문이다!

### 인덱스를 어디에 적용해야할까?

1. 카디널리티가 높은 컬럼에 적용해야한다!
    
    카디널리티는 그룹 내 요소의 개수이다. 
    
    예를 들어 성별의 카디널리티는 남, 녀 2개이다.
    
2. where, join, order by 절에 자주 사용되는 컬럼
3. INSERT/UPDATE/DELETE가 자주 발생하지 않는 컬럼
4. 규모가 큰 테이블


[참고]

[[10분 테코톡] 라라, 제로의 데이터베이스 인덱스](https://www.youtube.com/watch?v=edpYzFgHbqs)

면접을 위한 CS 전공지식 
