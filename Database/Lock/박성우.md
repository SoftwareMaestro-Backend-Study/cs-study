### 데이터의 일관성을 지키기 위해서, Lock을 건다!

`동시`에 접근하여 `수정`하려는 요청에 대해 `일관성`을 지키기 위해서 `Lock`을 건다.

# 종류

## Optimistic Lock

- 낙관적인 락
    
    기본적으로 데이터 갱신 시 충돌이 발생하지 않을 것이라고 낙관적으로 보는 것
    
    낙관적이기때문에, 우선적으로 Lock을 걸지 않는다.
    

### 동작 원리

Version을 통해서 관리한다.

예시)

상황 :  요청1과 요청2가 있고, 특정 리소스(`Version 1`) 을 수정할 때

- 요청1이 `Version 1` 인 리소스를 조회한다.
- 요청2가 `Version 1` 인 리소스를 조회한다.
- 요청1이 리소스를 수정하고 `Version 2` 로 변경한다.
- 요청2가 리소스를 수정할 때 `Version 1` 이 아니므로 예외를 발생시킨다.

JPA를 사용할 때는 `@Version` 어노테이션을 사용하면 된다!

- 데드락의 가능성이 적으며 성능 상의 이점이 있다.
- 충돌이 발생하면 충돌 시점의 모든 작업이 롤백된다.

## Pessimistic Lock

- 비관적인 락
    
    기본적으로 데이터 갱신시 충돌이 발생할 것이라고 비관적으로 보고 미리 잠금을 거는 것
    
    데이터 갱신시 충돌이 발생할 것이라고 예상하기 때문에, 우선적으로 락을 건다.
    

### 동작 원리

예시)

상황 :  요청1과 요청2가 있고, 특정 리소스를 수정할 때

- 요청1이 리소스를 조회한다.
- 요청2가 동일한 리소스를 조회 시도한다.
- 요청1이 리소스를 수정한다.
- 요청2가 요청1의 작업이 끝날 때까지 대기한다.
- 요청1이 리소스 수정 작업을 완료한다.
- 요청2가 리소스 수정 작업을 진행한다.

무결성의 장점이 있지만, 데드락의 위험성이 있다.

### Shared Lock

다른 사용자가 동시에 읽을 수는 있지만, 수정 작업은 할 수 없다.

### Exclusive Lock

다른 사용자가 리소스에 대한 접근 자체를 불가능하게 한다.

# 정리

Optimistic Lock은 동시 업데이트가 거의 없는 경우에 적용한다.

Persimistic Lock은 동시 업데이트가 빈번한 경우에 적용한다.
