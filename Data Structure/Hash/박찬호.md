## Hash Table

- **Hash table(hash map)이란 해시함수를 사용해서 변환한 값을 index로 삼아 key와 value를 저장하는 자료구조**
- **hash function**
    - key 값을 **고정된 길이**의 hash값으로 변경해주는 역할을 한다.
    - **해시충돌** 발생 가능 **-** 서로 다른 key가 hashing 후 같은 hash값이 나오는 경우
- value
    - Buckets에 최종적으로 저장되는 값으로, hash값 매칭되어 저장
- 시간 복잡도: key-value가 1:1 매핑되어 있기 때문에 **검색, 삽입, 삭제 과정에서 모두 평균적으로 O(1)의 시간복잡도**를 갖는다.
- 공간 복잡도: O(N), N은 Key의 개수
- 장점: 매우 빠른 시간 내로 삽입, 삭제, 검색이 가능하다.
- 단점
    - 해시 충돌이 발생할 수 있다.
    - 순서/관계가 있는 데이터에는 비효율적이다.
    - hash function의 의존도가 높다.

## Hash 충돌

서로 다른 key값에 대해서 동일한 hash값이 나오는 경우 key-value가 1:1로 매핑되지 않는다. 이를 해시 충돌이라 한다.

![image](https://github.com/SoftwareMaestro-Backend-Study/cs-study/assets/83508073/f9ea4496-f7b7-41e6-bce6-450bb0587d02)

### 비둘기집 원리

**비둘기집 원리**는 n+1개의 물건을 n개의 상자에 넣을 때 적어도 어느 한 상자에는 두 개 이상의 물건이 들어 있다는 원리를 말한다.

> n개의 비둘기 집과 n+1마리의 비둘기가 있다고 가정한다.
만약 각 비둘기집에 한 마리 이하의 비둘기만 들어 있다면, 전체 비둘기집에는 많아야 n마리의 비둘기가 존재한다. 그런데 비둘기는 모두 n+1 마리이므로, 이는모순이다.
따라서 어느 비둘기집에는 2마리 이상의 비둘기가 있다.
> 

따라서 비둘기집 원리에 의해서 input의 개수가 bucket의 개수보다 많을 경우 무조건 해시 충돌이 발생한다.

### Hash 충돌 완화

**(1) Separate Chaining**

![image](https://github.com/SoftwareMaestro-Backend-Study/cs-study/assets/83508073/7faf4d03-46dc-4b54-bcd4-ceffe900f473)

- 동일한 bucket에 **Linked list**나 **tree**를 연결하여 1개 이상의 value를 저장하는 방법
- 해시 충돌이 발생하더라도  **Linked list**나 **tree**를 연결되었기 때문에 데이터 개수에 제약이 없다.
- 하지만, 성능이 좋지 않다.

**(2) Open Addressing**

![image](https://github.com/SoftwareMaestro-Backend-Study/cs-study/assets/83508073/dc430e1f-be26-4b94-8c36-b983c9422687)

- 해시 충돌이 발생하는 경우 빈 곳을 찾아가서 채우는 방법이다.
1. **Linear Probing:** 현재의 버킷 index로부터 고정폭 만큼씩 이동하여 차례대로 검색해 비어 있는 버킷에 데이터를 저장한다.
2. **Quadratic Probing**: 해시의 저장순서 폭을 제곱으로 저장하는 방식이다. 예를 들어 처음 충돌이 발생한 경우에는 1만큼 이동하고 그 다음 계속 충돌이 발생하면 2^2, 3^2 칸씩 옮기는 방식이다.
3. **Double Hashing Probing**: 해시된 값을 한번 더 해싱하여 해시의 규칙성을 없애버리는 방식이다. 해시된 값을 한번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산을 하게 된다.

## 좋은 Hash Function

특정 값에 치우치지 않고 해시값을 고르게 만들어내는 해시함수가 좋은 해시함수라고 할 수 있다.

- **division method**
    - 가장 기본적인 해시 함수이다. 숫자로 된 키를 해시테이블 크기 m으로 나눈 나머지를 해시값으로 변환한다. 간단하면서도 빠른 연산이 가능한 것이 장점이다.
    - 해시의 중복을 방지하기 위해 테이블의 크기 m은 소수로 지정해서 사용하는것이 좋다. 하지만 남는 공간이 발생해 메모리상으로 비효율적이다.
- **multiplication method**
    - 숫자 키 k, A는 0<A<1 사이의 실수 일때 `h(k) = (ka mod 1)*m 으로 계산한다.
    - 2진수 연산에 최적화된 컴퓨터구조를 고려한 해시함수이다.
- **univeral hasing**
    - 여러개의 해시함수를 만들고, 이 해사함수의 집합 H에서 무작위로 해시함수를 선택해 해시값을 만드는 기법.
    - 서로 다른 해시함수가 서로 다른 해시값을 만들어내기 때문에 같은 공간에 매핑할 확률을 줄이는 것이 목적
