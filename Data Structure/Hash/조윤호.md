# Hash
- 해시함수를 사용하여 키를 해시값으로 매핑
- 이 해시값을 주소로 하여 데이터(value)를 key와 함께 저장하는 자료구조
- 삽입, 삭제, 검색 시간이 O(1)으로 빠르다.

### 해시 함수
- 해시값을 계산하기 위한 함수

### 이상적인 해시 함수의 조건
- 단방향 함수 : 해시값으로 키를 알 수 없다.
- 입력값에 작은 변화가 있어도 출력값의 변화가 커야 한다.
- 동일한 입력이 주어지면 동일한 출력이 출력되어야 한다.

# Hash Algorithm
### djb2 algorithm
- 5381과 33을 활용한 해시키 생성
- 다른 수도 가능(되도록 큰 소수이면 좋다!)
```c++
unsigned long djb2(unsigned char* str) {
    unsigned long hash = 5381;
    int c;
    while (c = *str++) {
                hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
    }
    return hash;
}
```

### SHA
- Secure Hash Algorithm
- 해시값의 길이를 160비트로 고정
- SHA-1, SHA-2, SHA-3 등이 있다.


# Hash Collision
- 다른 값이더라도 동일한 해시값이 나올 수 있다.
- 중복을 해결하기 위한 방법 필요

### Open Addressing
- 충돌이 발생하면 다른 해시키를 찾아서 저장하는 방식

- 선형 탐사(Linear Probing)
    - +1 혹은 +n에 저장하는 방식 (n은 소수)
    - 해시키가 연속적으로 저장되어 있어 캐시 효율이 좋다.
    - 그러나 클러스터링이 발생할 수 있다.
- 제곱 탐사(Quadratic Probing)
  - 충돌이 발생하면 제곱만큼 건너뛰어서 저장하는 방식
  - 선형 탐사보다 클러스터링이 적다.
- 이중 해시(Double Hashing)
  - 충돌이 발생하면 다른 해시 함수를 사용하여 저장하는 방식
  - 해시 함수가 충돌을 최소화하는 것이 중요하다.
  - 그러나 해시 함수가 복잡하면 성능이 떨어진다.

### Chaining
- linked list 사용하여 충돌된 자료를 기존 자료 다음에 위치시키는 방식
- 장점
  - 한정된 저장소를 효율적으로 사용
  - 상대적으로 적은 메모리 (해시테이블은 리스트보다 빈 공간이 많기 때문에)
- 단점
  - 검색 효율이 떨어짐(O(1) -> O(n))